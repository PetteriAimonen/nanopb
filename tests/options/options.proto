/* Test nanopb option parsing.
 * options.expected lists the patterns that are searched for in the output.
 */

syntax = "proto2";

import "nanopb/options.proto";

// File level options
option (nanopb.fileopt).max_size = 20;

message Message1
{
    required string filesize = 1;
}

// Message level options
message Message2
{
    option (nanopb.msgopt).max_size = 30;
    required string msgsize = 1;
}

// Field level options
message Message3
{
    option (nanopb.msgopt).msgid = 103;
    required string fieldsize = 1 [(nanopb.fieldopt).max_size = 40];
    required string fieldlen = 2 [(nanopb.fieldopt).max_length = 40];
}

// Forced callback field
message Message4
{
    option (nanopb.msgopt).msgid = 104;
    required int32 int32_callback = 1 [(nanopb.fieldopt).type = FT_CALLBACK];
}

// Short enum names
enum Enum1
{
    option (nanopb.enumopt).long_names = false;
    EnumValue1 = 1;
    EnumValue2 = 2;
}

message EnumTest
{
    required Enum1 field = 1 [default = EnumValue2];
}

// Short enum names inside message
message Message5
{
    option (nanopb.msgopt).msgid = 105;
    enum Enum2
    {
       option (nanopb.enumopt).long_names = false;
       EnumValue1 = 1;
    }
    required Enum2 field = 1 [default = EnumValue1];
}

// Packed structure
message my_packed_struct
{
    option (nanopb.msgopt).packed_struct = true;
    optional int32 myfield = 1;
}

// Message with ignored field
message Message6
{
    required int32 field1 = 1;
    optional int32 skipped_field = 2 [(nanopb.fieldopt).type = FT_IGNORE];
}

// Message that is skipped
message SkippedMessage
{
    option (nanopb.msgopt).skip_message = true;
    required int32 foo = 1;
}

// Message with oneof field
message OneofMessage
{
    oneof foo {
        int32 bar = 1;
    }
}

// Proto3-style optional field in proto2 file
message Proto3Field
{
    optional int32 proto3field = 1 [(nanopb.fieldopt).proto3 = true];
}

